/**
 * POOT
 * The Zebro Project
 * Delft University of Technology
 * 2016
 *
 * Filename: pootbus.c
 *
 * Description:
 * Code for the interface with the PootBus
 * The PootBus uses the I2C2 bus
 *
 * Warning:
 * A PootBus transfer should never be initiated form an ISR,
 * as this will introduce a shared data problem.
 *
 * @author Piet De Vaere -- Piet@DeVae.re
 */

#include <interrupts.h>
#include "stdint.h"
#include "stm32f0xx_hal.h"

#include "pootbus.h"
#include "vregs.h"
#include "leds.h"
#include "errors.h"
#include "time.h"
#include "errors.h"
#include "globals.h"

/* Used for the PootBus statemachine */
static int32_t state = POOTBUS_STATE_IDLE;
/* Raw data received from the temperatures sensors */
static uint8_t raw_data[2][POOTBUS_NUM_OF_SENSORS][POOTBUS_NUM_OF_BYTES];
/* used during the read cycle, to remember where to write data to */
static int32_t data_destination = 0;
/* used for the alternating buffers */
static int32_t buffer_selector = 0;
/* used to store converted temperatures */
static int32_t pootbus_temperatures_fp3[POOTBUS_NUM_OF_SENSORS];
/* used to detect timeouts on the pootbus */
static int32_t pootbus_transaction_start_time = 0;

/**
 * Set the state of PootBus, and write it to the vregs
 */
inline void pootbus_set_state(int32_t new_state){
	state = new_state;
#ifdef DEBUG_VREGS
	vregs_write(VREGS_POOTBUS_STATE, (uint8_t) new_state);
#endif
}

/**
 * Set up the PootBus
 */
int32_t pootbus_master_init(){
	GPIO_InitTypeDef  GPIO_InitStruct;

	/* enable GPIO pins */
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/* set up the GPIO pins */
    GPIO_InitStruct.Pin = POOTBUS_SDA_PIN | POOTBUS_SCL_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF1_I2C2;

	HAL_GPIO_Init(POOTBUS_SCL_BANK, &GPIO_InitStruct);

	/* enable the ISR in the NVIC, give it a low priority */
	NVIC_EnableIRQ(I2C2_IRQn);
	NVIC_SetPriority(I2C2_IRQn, POOTBUS_IRQ_PRIORITY);

	/* enable clock to peripheral */
	__HAL_RCC_I2C2_CLK_ENABLE();

//	/* set up the peripheral */
//	I2C2->TIMINGR = (uint32_t)0x20303e5d;
	/* set up the peripheral */
	I2C2->TIMINGR = (uint32_t)0x0070D8FF; /* I2C freq 100 khz, clock 48000 KHz, no analog filter, 0 digital filter, 65 ns rise time, 5 ns fall time. */
	/* enable peripheral, and requests interupts for:
	 * * errors
	 * * transfer complete
	 * * NACK received
	 * * RX buffer not empty
	 */
	I2C2->CR1 = I2C_CR1_PE | I2C_CR1_ERRIE |
			I2C_CR1_TCIE | I2C_CR1_NACKIE | I2C_CR1_RXIE;

	return 1;
}

/**
 * Get a value from one of the temperature sensors.
 * This function is not reentrant
 */
int32_t pootbus_read_temperature(uint8_t slave_address){
	/* check if the bus is busy */
	if (I2C2->ISR & I2C_ISR_BUSY){
#ifdef DEBUG_VREGS
		vregs_write(VREGS_POOTBUS_BUSY, 1);
#endif
		return POOTBUS_BUS_BUSY;
	}

	/**
	 * Begin critical section
	 */
	interrupts_disable();

	if (state != POOTBUS_STATE_IDLE){
#ifdef DEBUG_VREGS
		vregs_write(VREGS_POOTBUS_BUSY, 2);
#endif
		interrupts_enable();
		return POOTBUS_BUS_BUSY;
	}

	/* claim the PootBus */
	pootbus_set_state(POOTBUS_TEMP_SEND_ADDRESS);
	pootbus_transaction_start_time = time_get_time_ms();
	interrupts_enable();
	/**
	 * End critical section
	 */

#ifdef DEBUG_VREGS
	vregs_write(VREGS_POOTBUS_BUSY, 0);
#endif

	/* remember where to write data to */
	switch(slave_address){
		case POOTBUS_TEMPSENSOR_111_ADR:
			data_destination = POOTBUS_TEMPSENSOR_111_DEST;
			break;
		case POOTBUS_TEMPSENSOR_100_ADR:
			data_destination = POOTBUS_TEMPSENSOR_100_DEST;
			break;
		default:
			pootbus_set_state(POOTBUS_STATE_IDLE);
			return POOTBUS_BAD_ADDRESS;
	}

	/* request register 0 */
	I2C2->TXDR = 0x00;
	/* transfer to the slave, one byte at a time */
	I2C2->CR2 =  I2C_CR2_START | slave_address | (1 << 16);
	return 0;
}

/**
 * The interrupt handler for PootBus (I2C2)
 */
void I2C2_IRQHandler(){

	/* in case of a bus error */
	if((I2C2->ISR & I2C_ISR_BERR) || (I2C2->ISR & I2C_ISR_ARLO)){
		/* stop the transfer */
		I2C2->CR2 |= I2C_CR2_STOP;
		/* clear the error flag */
		I2C2->ICR |= I2C_ICR_BERRCF | I2C_ICR_ARLOCF;
		/* free the bus */
		pootbus_set_state(POOTBUS_STATE_IDLE);
		/* report the error */
		errors_report(ERRORS_POOTBUS_ERROR);
		return;
	}

//	/* in case of a stop generated by the peripheral
//	 * a perhipheral should never generate a stop */
//	if(I2C2->ISR & I2C_ISR_STOPF){
//		/* stop the transfer */
//		I2C2->CR2 |= I2C_CR2_STOP;
//		/* clear the error flag */
//		I2C2->ICR |= I2C_ICR_STOPCF;
//		/* free the bus */
//		state = POOTBUS_STATE_IDLE;
//		//toda: report the error
//		return;
//	}

	/* in case of a NACK */
	if(I2C2->ISR & I2C_ISR_NACKF){
		/* stop the transfer */
		I2C2->CR2 |= I2C_CR2_STOP;
		/* clear the error flag */
		I2C2->ICR |= I2C_ICR_NACKCF;
		/* free the bus */
		pootbus_set_state(POOTBUS_STATE_IDLE);
		/* report the error */
		errors_report(ERRORS_POOTBUS_NACK);
		return;
	}

	switch(state){
//
	case POOTBUS_TEMP_SEND_ADDRESS:
		/* so, we just transmitted the address of the
		 * register we want to read to the temperature sensor.
		 * Now we have to restart and get two data bytes out.
		 */
		pootbus_set_state(POOTBUS_TEMP_RECEIVE_BYTE_1);

		/* read two bytes */
		I2C2->CR2 &= ~(0xFF << 16);
		I2C2->CR2 |= I2C_CR2_RD_WRN | I2C_CR2_START | (1 << 17);

		break;

	case POOTBUS_TEMP_RECEIVE_BYTE_1:
		/* We just received the first byte from the temperature sensor
		 * store it, and wait for the second one
		 */

		pootbus_set_state(POOTBUS_TEMP_RECEIVE_BYTE_2);

		/* store the data received */
		raw_data[buffer_selector][data_destination][0] = (uint8_t) I2C2->RXDR;

		break;

	case POOTBUS_TEMP_RECEIVE_BYTE_2:
		/* We just received the second byte from the temperature sensor
		 * store it, and finish up the transaction.
		 */

		pootbus_set_state(POOTBUS_STATE_IDLE);
		raw_data[buffer_selector][data_destination][1] = (uint8_t) I2C2->RXDR;

		I2C2->CR2 |=  I2C_CR2_STOP;
		break;

	case POOTBUS_STATE_IDLE:
		break;
	default:
		/* this should not happen, but if it does, try to fix things */
		pootbus_reset();
		errors_report(ERRORS_POOTBUS_UNEXPECTED);
		return;
	}
}

/**
 * Reset the I2C2 perhiperheral
 */
void pootbus_reset(){
	volatile int32_t i;

	/* disable I2C2  */
	I2C2->CR1 &= ~I2C_CR1_PE;
	/* add some delay */
//	for(i = 0; i < 10; i++);
	if (i<10) {
		i++;
	} else {
		/* enable I2C2 */
		I2C2->CR1 |= I2C_CR1_PE;
		pootbus_set_state(POOTBUS_STATE_IDLE);
		i = 0;
	}
//	I2C2->CR2 |=  I2C_CR2_STOP;
//	/* clear all flags */
//	I2C2->ICR |= I2C_ICR_STOPCF | I2C_ICR_OVRCF | I2C_ICR_ARLOCF |
//				I2C_ICR_BERRCF | I2C_ICR_NACKCF | I2C_ICR_ADDRCF |
//				I2C_ICR_TIMOUTCF;
//	if(I2C2->RXDR);
}

/**
 * Calculate the temperatures. Also writing a copy to the vregs.
 */
void pootbus_calc_temperatures(){
	int32_t i;
	buffer_selector = !buffer_selector;

	/* calculate the temperatures */

	for(i = 0; i < POOTBUS_NUM_OF_SENSORS; i++){
		int32_t temperature;
		temperature = (int32_t)(raw_data[!buffer_selector][i][0]);

		temperature = temperature << 3;
		temperature += (int32_t)(raw_data[!buffer_selector][i][1] >> 5);
		temperature *= 125; // now in milli degrees C

		pootbus_temperatures_fp3[i] = temperature;

		// Checking if conversion is going right.
//		if (i == 0) {
//			vregs_write(VREGS_DEBUG_FLAG_6, temperature / 1000);
//		}
//		if (i == 1) {
//			vregs_write(VREGS_DEBUG_FLAG_7, temperature / 1000);
//		}
	}

	/* write the temperature values to the vregs */
	vregs_write(VREGS_POOTBUS_TEMP111,
			raw_data[!buffer_selector][POOTBUS_TEMPSENSOR_111_DEST][0]);
	vregs_write(VREGS_POOTBUS_TEMP100,
			raw_data[!buffer_selector][POOTBUS_TEMPSENSOR_100_DEST][0]);
}

/**
 * if the PootBus is done, start a new data request
 */
void pootbus_request_data(){
	static int32_t cycle_position = 0;
	pootbus_check_for_timeout();

	switch(cycle_position){

	case 0:
		if (!pootbus_read_temperature(POOTBUS_TEMPSENSOR_111_ADR)){
			cycle_position++;
		}
		break;

	case 1:
		if (!pootbus_read_temperature(POOTBUS_TEMPSENSOR_100_ADR)){
			cycle_position++;
		}
		break;
	case 2:
	default:
		if(state == POOTBUS_STATE_IDLE){
			pootbus_calc_temperatures();
			cycle_position = 0;
		}
	}
}

/**
 * Check if a timeout has ocurred on PootBus. If this is the case,
 * the bus is probably hanging and should be reset.
 */
int32_t pootbus_check_for_timeout(void){
	int32_t current_time;

	/**
	 * Begin critical section
	 */
	interrupts_disable();

	if(state == POOTBUS_STATE_IDLE && !(I2C2->ISR & I2C_ISR_BUSY)){
		interrupts_enable();
		return 0;
	}

	current_time = time_get_time_ms();

//	/* the clock has made a rollover */
//	if (current_time < pootbus_transaction_start_time){
//		current_time += TIME_ROLEOVER_MS;
//	}

	/* this is true when the transaction
	 * has taken more than the time out value */
	if ((time_calculate_delta(current_time, pootbus_transaction_start_time)) > POOTBUS_MAX_TRANSACTION_TIME){
		/* put the bus to idle mode, reseting things */
		pootbus_reset();
		/* raise an error */
		errors_report(ERRORS_POOTBUS_TIMOUT);

		interrupts_enable();
		return POOTBUS_TIMEOUT;
	}

	interrupts_enable();
	/**
	 * End critical section
	 */

	return 0;
}

/**
 * Returns the temperature of a sensor in milli degrees C
 */
int32_t pootbus_get_motor_temperature_fp3(int32_t index){
	return pootbus_temperatures_fp3[index];
}

/**
 * Check if any of the motors is to hot.
 */
int32_t pootbus_check_motor_temperatures(){
	int32_t index;
	static uint8_t counter = 0;

	for (index = 0; index < POOTBUS_NUM_OF_TEMP_SENSORS; index++){
		if (pootbus_temperatures_fp3[index] >
			POOTBUS_EMERGENCY_MOTOR_TEMPERATURE * 1000){
			counter += 1;
			if (counter >= 100) {
				errors_emergency_stop();
				errors_report(ERRORS_MOTOR_OVERTEMPERATURE);
			}
			return 1;
		} else {
			if (counter > 0) {
				counter -= 1;
			}
		}

	}

	return 0;
}
